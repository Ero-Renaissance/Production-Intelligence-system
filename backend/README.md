# Production Gap & Cargo Forecast – Backend Overview

This document orients backend developers to the overall system, how the frontend is wired, the API contract the frontend expects, and the technical requirements for building and running the backend.

## Purpose
The app is a production intelligence dashboard for an oil and gas operator. It exposes drill‑down views across a domain hierarchy:
- Asset → Production Hub → Facility → Network
- Networks: oil, domestic gas, export gas, flared gas (flared gas should always be present)

The backend will provide a stable, versioned API consumed by a React frontend.

## System architecture (high level)
- frontend: React 18 + TypeScript + Vite + TailwindCSS, React Router v6, Axios + React Query
- backend: FastAPI (Python 3.11+), Pydantic v2 for contracts
- contracts: OpenAPI generated by FastAPI; optional type generation for frontend
- hosting (recommended on Azure):
  - Frontend: Azure Static Web Apps or Azure Storage Static Website + CDN/Front Door
  - Backend: Azure App Service (Linux) running containerized FastAPI (uvicorn/gunicorn)
  - Gateway/Governance: Azure API Management (APIM) in front of the API
  - Observability: Azure Application Insights
  - Secrets: Azure Key Vault

## Frontend at a glance (what the backend must support)
- Routing: SPA with routes including `/`, `/asset/:assetId`, `/asset/:assetId/hub/:hubId`, `/facility/:facilityId`
- Data fetching: Axios + React Query; default behavior expects JSON payloads (no custom envelope)
- Mocking: In dev, the frontend can use MSW toggled by env flags. In integration mode, it calls the real API base URL.
- KPI cards show, per network: maxCapacity, businessTarget, currentProduction, deferment. Terminals show a specific set of KPIs.

## Domain model (shared language)
- Asset: East, West
- Production hub (aka production unit) within each asset
- Facility types: flowstation, compressor-station, gas-plant, terminal
- Facility supports one or more networks: oil, domesticGas, exportGas, flaredGas
- Flared gas: always present across assets/hubs/facilities

### KPI model
- For facilities (non-terminal):
  - maxCapacity
  - businessTarget
  - currentProduction
  - deferment
- For terminals:
  - maxCapacity (million barrels)
  - grossStock (million barrels)
  - readyCrude (thousand barrels per day)
  - productionRate (thousand barrels per day)
  - endurance (days)

## API contract (initial endpoints expected by the frontend)
Base path and versioning:
- Use `/api/v1` for all routes
- JSON responses; UTF-8; snake_case or camelCase are acceptable but must be consistent. Below uses camelCase.

Endpoints (summary):
- GET `/api/v1/summary`
  - Returns overall KPIs (east/west and system totals). Includes flaredGas.
- GET `/api/v1/assets`
  - Returns assets, their production hubs, and facilities, including each facility’s networks and KPIs.
- GET `/api/v1/gap-drivers?assetId=...&facilityIds=facility-1,facility-2`
  - Returns top contributors to deferment. Supports optional filtering.
- GET `/api/v1/production-flow`
  - Returns explicit topology: units, facilities, and edges (for a flow map view). Purely structural.
- GET `/api/v1/terminal/{terminalId}/operations`
  - Returns the 5 terminal KPIs listed above.
- GET `/api/v1/hubs/{hubId}/performance?window=7d|30d|90d`
  - Returns hub-level performance trend points for a time window (for charts).

Response conventions:
- Success: return the domain object directly (no envelope)
- Errors: return RFC 7807 Problem Details (`application/problem+json`) including `type`, `title`, `status`, `detail`, and optional `instance`
- Numbers should be returned in base units and consistently documented; the frontend will format units for display

## Environment and configuration
Backend (FastAPI):
- PORT (default 8000)
- CORS_ALLOWED_ORIGINS (comma-separated; e.g., http://localhost:5173, https://your-frontend.example.com)
- LOG_LEVEL (info|debug|warning|error)
- DATABASE_URL (future; e.g., Azure PostgreSQL or SQL Server)
- APPLICATION_INSIGHTS_CONNECTION_STRING (optional)
- AZURE_* (optional, for Entra ID/OIDC later)

Adapters (optional; set only what you use):
- Energy Components (Oracle via python-oracledb):
  - EC_DB_HOST, EC_DB_PORT, EC_DB_SERVICE_NAME, EC_DB_USER, EC_DB_PASSWORD, EC_DB_POOL_MIN, EC_DB_POOL_MAX, EC_DB_POOL_INC
- Energy Components (REST):
  - EC_API_BASE_URL, EC_API_CLIENT_ID, EC_API_CLIENT_SECRET, EC_API_SCOPE, EC_API_TIMEOUT_SECONDS
- PI System Web API:
  - PI_BASE_URL, PI_AUTH_MODE, PI_USERNAME, PI_PASSWORD, PI_CLIENT_ID, PI_CLIENT_SECRET, PI_TIMEOUT_SECONDS
- SharePoint (Graph):
  - SP_TENANT_ID, SP_CLIENT_ID, SP_CLIENT_SECRET, SP_AUTHORITY, SP_GRAPH_SCOPE, SP_SITE_ID, SP_LIST_ID, SP_DRIVE_ID, SP_TIMEOUT_SECONDS
- Cache/Jobs (optional):
  - REDIS_URL, CACHE_DEFAULT_TTL_SECONDS, REFRESH_CRON_ASSET, REFRESH_CRON_TERMINAL

Frontend (for reference):
- VITE_API_BASE_URL (e.g., http://localhost:8000/api/v1 or simply /api/v1 if reverse-proxied)
- VITE_USE_MSW=true|false (toggle mock service worker in dev)
- VITE_PREVIEW_MSW=true|false (optional flag to enable MSW in preview environments)

## Local development
Prereqs:
- Python 3.11+
- Node.js 18+ (frontend dev)

Recommended workflow:
1) Backend
   - Create and activate a virtualenv
   - `pip install -r backend/requirements.txt`
   - Run dev server: `uvicorn app.main:app --reload --port 8000`
   - Enable CORS for `http://localhost:5173` (Vite default) or your chosen origin

2) Frontend
   - Set `VITE_API_BASE_URL=http://localhost:8000/api/v1`
   - `npm install && npm run dev`

3) Contracts
   - Expose FastAPI OpenAPI at `/api/v1/openapi.json`
   - Optionally generate TS types in the frontend with `openapi-typescript`

## Authentication & authorization (enterprise-ready plan)
- Azure Entra ID (formerly Azure AD) via OIDC/OAuth2
- Frontend uses MSAL to obtain access tokens; backend validates JWTs
- Start unauthenticated during early dev; add auth middleware before UAT

## Deployment to Azure (recommended path)
- Frontend: Azure Static Web Apps (or Storage Static Website) + CDN/Front Door
- Backend: Azure App Service (Linux) with containerized FastAPI (uvicorn/gunicorn)
- APIM: Front the API for routing, policies, and versioning
- App Insights: Metrics, traces, logs; add health endpoints (e.g., `/healthz`)
- Key Vault: Store secrets (DB, client secrets)
- Networking: Private endpoints/VNet as required by enterprise policy

## Observability & reliability
- Structured JSON logs
- App Insights tracing (correlation via headers)
- Health checks: liveness and readiness endpoints
- Rate limiting & circuit breaking (via APIM policies, if needed)

## Proposed backend folder layout
```
backend/
  app/
    main.py                # FastAPI app, routers include, middleware
    api/
      routes/              # Route modules (summary, assets, gap_drivers, terminals, hubs)
      deps.py              # FastAPI dependencies (auth, db sessions)
    core/
      config.py            # Settings & env parsing
      clients.py           # HTTP/db clients & adapter factories
      logging.py           # Logging setup (future)
    adapters/              # External system adapters (EC/PI/SharePoint)
    services/              # Business orchestration mapping to SPA contract
    repositories/          # Data access (DB or upstream services)
  tests/
    api/                   # API tests (pytest + httpx)
  requirements.txt
  README.md
```

## Versioning & compatibility
- Prefix all routes with `/api/v1`
- Use additive changes where possible; avoid breaking fields. For breaking changes, introduce `/api/v2` and deprecate v1.

## What to implement next
1) Flesh out concrete adapters using your enterprise connectivity (Oracle EC, PI Web API, Graph)
2) Add service layer modules to assemble responses for the SPA
3) Implement endpoints for `/summary`, `/assets`, `/gap-drivers`, `/production-flow`, `/terminal/{id}/operations`, `/hubs/{id}/performance`
4) Add examples in OpenAPI and contract tests 